<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
    const int MAX_GENERICS = 16;

    string GenerateSequence(int count, string separator, System.Func<int, string> generator)
    {
        var sb = new StringBuilder();
        for (var i = 0; i < count; ++i)
        {
            sb.Append(generator(i));
            if (i < count - 1)
            {
                sb.Append(separator);
            }
        }
        return sb.ToString();
    }

    var stageNames = new[]
    {
        new { StageName = "Startup", MethodName = "OnStartup" },
        new { StageName = "FrameStart", MethodName = "OnFrameStart" },
        new { StageName = "BeforeUpdate", MethodName = "OnBeforeUpdate" },
        new { StageName = "Update", MethodName = "OnUpdate" },
        new { StageName = "AfterUpdate", MethodName = "OnAfterUpdate" },
        new { StageName = "FrameEnd", MethodName = "OnFrameEnd" }
    };
#>
#pragma warning disable 1591
#nullable enable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;

namespace TinyEcs
{
#if NET9_0_OR_GREATER
    public partial class Scheduler
    {
<#
    foreach (var stage in stageNames)
    {
        for (var i = 0; i < MAX_GENERICS; ++i)
        {
            var genericsArgs = GenerateSequence(i + 1, ", ", j => $"T{j}");
            var genericsArgsWhere = GenerateSequence(i + 1, "\n\t\t\t", j => $"where T{j} : class, ISystemParam<World>, IIntoSystemParam<World>");
            var objs = GenerateSequence(i + 1, "\n\t\t\t", j => $"T{j}? obj{j} = null;");
            var objsGen = GenerateSequence(i + 1, "\n\t\t\t\t", j => $"obj{j} ??= (T{j})T{j}.Generate(args);");
            var objsLock = GenerateSequence(i + 1, "\n\t\t\t\t", j => $"obj{j}.Lock(ticks);");
            var objsUnlock = GenerateSequence(i + 1, "\n\t\t\t\t", j => $"obj{j}.Unlock();");
            var systemCall = GenerateSequence(i + 1, ", ", j => $"obj{j}");
#>
        public ITinySystem <#= stage.MethodName #><<#= genericsArgs #>>(Action<<#= genericsArgs #>> system, ThreadingMode? threadingType = null)
            <#= genericsArgsWhere #>
        {
            if (!threadingType.HasValue)
                threadingType = ThreadingExecutionMode;

            <#= objs #>
            var fn = (World args, SystemTicks ticks) =>
            {
                <#= objsGen #>
                <#= objsLock #>
                args.BeginDeferred();
                system(<#= systemCall #>);
                args.EndDeferred();
                <#= objsUnlock #>
                return true;
            };
            var sys = new TinyDelegateSystem(fn);
			sys.Configuration.ThreadingMode = threadingType;
            Add(sys, Stages.<#= stage.StageName #>);
            return sys;
        }

<#
        }
    }

    // Also add versions that take just Action with no parameters
    foreach (var stage in stageNames)
    {
#>
        public ITinySystem <#= stage.MethodName #>(Action system, ThreadingMode? threadingType = null)
        {
            if (!threadingType.HasValue)
                threadingType = ThreadingExecutionMode;

			var fn = (World args, SystemTicks ticks) =>
			{
				system();
                return true;
			};

            var sys = new TinyDelegateSystem(fn);
			sys.Configuration.ThreadingMode = threadingType;
            Add(sys, Stages.<#= stage.StageName #>);
            return sys;
        }

<#
    }
#>
    }
#endif
}

#pragma warning restore 1591
